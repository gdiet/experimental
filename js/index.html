<!DOCTYPE html>
<html lang="de">
  
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shamir's Secret Sharing</title>
</head>

<body>
  <h1>Shamir's Secret Sharing</h1>
  <h2>Implementierung im "mod 257" Raum</h2>

  <p>Zu teilendes Geheimnis: <input id="secretTextInput" type="text" value="Geheimnis"></p>
  <p><button id="secretTextToHexButton">UTF-8 hexadezimal umrechnen</button></p>
  <p>Geheimnis hexadezimal: <input id="secretHexInput" type="text" value=""></p>
  <p><input type="radio" id="randomCoefficients" name="coefficients" checked>
    Zufällige Koeffizienten: <span id="generatedCoefficients"></span></p>
  <p><input type="radio" id="staticCoefficients" name="coefficients">
    Feste Koeffizienten: <input id="userCoefficients" type="text" value="1,5,3"></p>
  <p>Zu erstellende Teile n, mit k <= n <= 256:
    <input id="numberOfShares" type="number" min="2" max="256" value="5"></p>
  <p>Benötigte Teile für Rekonstruktion k, mit 2 <= k:
    <input id="threshold" type="number" min="2" max="256" value="3"></p>
  <p>Polynom: <span id="polynomial"></span></p>
  <p><button id="createSharesButton">Teile erstellen</button></p>
</body>

<script>

// Text utility functions
const utf8ToBytes  = text  => Array.from(new TextEncoder('UTF-8').encode(text))
const toHex        = byte  => byte.toString(16).padStart(2, '0')
const toHexSpaced  = array => array.map(byte => toHex(byte)).join(" ")
const toHexCompact = array => array.map(byte => toHex(byte)).join("")

// min, max: The minimum is inclusive and the maximum is exclusive
const random       = (min, max) => Math.floor(Math.random() * (max - min) + min)
const randomByte   = ()         => random(0, 256)
const randomBytes  = count      => Array.from({length: count}, () => randomByte() )

// Document utilitiy functions
const byId         = id                  => document.getElementById(id)
const listen       = (id, event, action) => byId(id).addEventListener(event, action)

// Helper functions for improved readability
const foldLeft     = (array, zero, func) => array.reduce(func, zero)

// Maths for secret sharing and reconstruction
const mod = (a, n) => ((a % n) + n) % n
const inverse = (a, n) => {
    for (k = 1; k < n; k++) if (mod(k * a, n) == 1) return k
    throw new Error(`${a} is not invertible mod ${n}`) 
}
const interpolate = (data, x, n) => 
    foldLeft(data, 0, (r, e1, i) =>
        mod(foldLeft(data, e1.y, (t, e2, j) =>
            i == j ? t : mod(t * (x - e2.x) * inverse(e1.x - e2.x, n), n)
        ) + r, 257)
    )
const exp = (a, e, n) => { if (a == 0) return 0
  factor = e >= 0 ? a : inverse(a, n)
  for (k = 1, r = 1; k <= Math.abs(e); k++) r = mod(r * factor, n)
  return r
}
const calculatePolynomial = (x, coefficients, n) =>
  foldLeft(coefficients, 0, (r, c, i) => mod(r + c * exp(x, i, n), n))

// Dynamic document content functions
const coefficientHtml = index => {
  coefficientsText = byId('staticCoefficients').checked ? byId('userCoefficients').value : byId('generatedCoefficients').innerHTML
  return Number(coefficientsText.split(',')[index-1]) || 1
}
const setPolynomialAndGeneratedCoefficientsHtml = () => {
  threshold = byId('threshold').value
  coefficients = Array.from({length: threshold - 2}, () => random(0, 257))
  coefficients.push(random(1, 257)) // The last coefficient must not be 0.
  byId('generatedCoefficients').innerHTML = coefficients.join(',')
  for (k = 1, html = `P(x) = secret`; k < threshold; k++) html += ` + ${coefficientHtml(k)}x<sup>${k}</sup>`
  byId('polynomial').innerHTML = html + ' | (mod 257)'
}
const setHexSecretHtml = () =>
  byId('secretHexInput').value = toHexCompact(utf8ToBytes(byId('secretTextInput').value))

// Document automation
setHexSecretHtml()
setPolynomialAndGeneratedCoefficientsHtml()

listen('secretTextToHexButton', 'click',  () => setHexSecretHtml())
listen('randomCoefficients',    'change', () => setPolynomialAndGeneratedCoefficientsHtml())
listen('staticCoefficients',    'change', () => setPolynomialAndGeneratedCoefficientsHtml())

listen('numberOfShares', 'change', () => {
  numberOfSharesRead = Math.floor(Math.abs(Number(byId('numberOfShares').value)))
  byId('numberOfShares').value = Math.min(256, Math.max(byId('threshold').value, numberOfSharesRead))
})
listen('threshold', 'change', () => {
  thresholdRead = Math.floor(Math.abs(Number(byId('threshold').value)))
  byId('threshold').value = Math.min(byId('numberOfShares').value, Math.max(2, thresholdRead))
  setPolynomialAndGeneratedCoefficientsHtml()
})

// to create a share for x,
// the first coefficient must be the secret,
// the middle coefficients should be random numbers,
// the last coefficient modulus 257 must not be 0.
// the total number of coefficients (including share)
// is the number of shares needed for reconstruction.
console.log(calculatePolynomial(2, [4,6,3], 257))


// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey
// for the signature - consider using a ecc key pair instead of rsa

/*
  <p><pre>
    {
      "whatIsThis": "A share of a secret, created with Shamir's Secret Sharing",
      "share": {
        "whatIsShared": "The combination of Tia Tester's Bank Safe",
        "x":1, "y":27,
        "polynomial": "P(x) = secret + ax^1 + bx^2 + cx^3 | (mod 257)"
      },
      "rsaPublicKey": "aabbcc",
      "whatIsSigned": "JSON.stringify(share).toUTF8ByteArray",
      "rsaSignature": "ddeeff"
    }
  </pre></p>
*/

</script>
  

</html>
