<!DOCTYPE html>
<html lang="de">
  
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shamir's Secret Sharing</title>
</head>

<body>
  <h1>Shamir's Secret Sharing</h1>
  <h2>Implementierung im "mod 257" Raum</h2>

  <p>Zu teilendes Geheimnis: <input id="secretTextInput" type="text" value="Geheimnis"></p>
  <p><button id="secretTextToHexButton">UTF-8 hexadezimal umrechnen</button></p>
  <p>Geheimnis hexadezimal: <input id="secretHexInput" type="text" value=""></p>
  <p><input type="radio" id="randomCoefficients" name="coefficients" checked>
    Zufällige Koeffizienten: <span id="generatedCoefficients"></span></p>
  <p><input type="radio" id="staticCoefficients" name="coefficients">
    Feste Koeffizienten: <input id="userCoefficients" type="text" value="1,5,3"></p>
  <p>Zu erstellende Teile n, mit k <= n <= 256:
    <input id="numberOfShares" type="number" min="2" max="256" value="5"></p>
  <p>Benötigte Teile für Rekonstruktion k, mit 2 <= k:
    <input id="threshold" type="number" min="2" max="256" value="3"></p>
  <p>Polynom: <span id="polynomial"></span></p>
</body>

<script>

// Text utility functions
const utf8ToBytes  = text  => Array.from(new TextEncoder('UTF-8').encode(text))
const toHex        = byte  => byte.toString(16).padStart(2, '0')
const toHexSpaced  = array => array.map(byte => toHex(byte)).join(" ")
const toHexCompact = array => array.map(byte => toHex(byte)).join("")

// min, max: The minimum is inclusive and the maximum is exclusive
const random       = (min, max) => Math.floor(Math.random() * (max - min) + min)
const randomByte   = ()         => random(0, 256)
const randomBytes  = count      => Array.from({length: count}, () => randomByte() )

// Document utilitiy functions
const byId         = id                  => document.getElementById(id)
const listen       = (id, event, action) => byId(id).addEventListener(event, action)

// Helper functions for improved readability
const foldLeft     = (array, zero, func) => array.reduce(func, zero)

// Maths for secret sharing
const mod     = (a, n) => ((a % n) + n) % n
const inverse = (a, n) => {
    for (k = 1; k < n; k++) if (mod(k * a, n) == 1) return k
    throw new Error(`${a} is not invertible mod ${n}`) 
}
const interpolate = (data, x, n) => 
    foldLeft(data, 0, (r, e1, i) =>
        mod(foldLeft(data, e1.y, (t, e2, j) =>
            i == j ? t : mod(t * (x - e2.x) * inverse(e1.x - e2.x, n), n)
        ) + r, 257)
    )

// Dynamic document content functions
const coefficientHtml = index => {
  coefficientsText = byId('staticCoefficients').checked ? byId('userCoefficients').value : byId('generatedCoefficients').innerHTML
  return Number(coefficientsText.split(',')[index-1]) || 1
}
const setPolynomialAndGeneratedCoefficientsHtml = () => {
  threshold = byId('threshold').value
  coefficients = Array.from({length: threshold - 2}, () => random(0, 257))
  coefficients.push(random(1, 257)) // The last coefficient must not be 0.
  byId('generatedCoefficients').innerHTML = coefficients.join(',')
  for (k = 1, html = `P(x) = secret`; k < threshold; k++) html += ` + ${coefficientHtml(k)}x<sup>${k}</sup>`
  byId('polynomial').innerHTML = html + ' | (mod 257)'
}
setPolynomialAndGeneratedCoefficientsHtml()
const setHexSecretHtml = () =>
  byId('secretHexInput').value = toHexCompact(utf8ToBytes(byId('secretTextInput').value))
setHexSecretHtml()

// Document automation
listen('secretTextToHexButton', 'click', () => {
  setHexSecretHtml()
} )

listen('randomCoefficients', 'change', () => setPolynomialAndGeneratedCoefficientsHtml())
listen('staticCoefficients', 'change', () => setPolynomialAndGeneratedCoefficientsHtml())

listen('numberOfShares', 'change', () => {
  numberOfSharesRead = Math.floor(Math.abs(Number(byId('numberOfShares').value)))
  byId('numberOfShares').value = Math.min(256, Math.max(byId('threshold').value, numberOfSharesRead))
})
listen('threshold', 'change', () => {
  thresholdRead = Math.floor(Math.abs(Number(byId('threshold').value)))
  byId('threshold').value = Math.min(byId('numberOfShares').value, Math.max(2, thresholdRead))
  setPolynomialAndGeneratedCoefficientsHtml()
})


// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey
// for the signature - consider using a ecc key pair instead of rsa

/*
  <p><pre>
    {
      "whatIsThis": "A share of a secret, created with Shamir's Secret Sharing",
      "share": {
        "whatIsShared": "The combination of Tia Tester's Bank Safe",
        "x":1, "y":27,
        "polynomial": "P(x) = secret + ax^1 + bx^2 + cx^3 | (mod 257)"
      },
      "rsaPublicKey": "aabbcc",
      "whatIsSigned": "JSON.stringify(share).toUTF8ByteArray",
      "rsaSignature": "ddeeff"
    }
  </pre></p>
*/


// // number 0 .. 255 => hex string 00 .. FF
// const hex   = byte  => byte.toString(16).padStart(2, '0')
// const hexes = array => array.map(byte => hex(byte)).join(" ")

// // log and antilog table for GF(256) with generator 3
// const calculate_exp = () => {
//     a = 0xf6
//     return Array.from({length: 510}, () => { a = (a < 128) ? (a << 1 ^ a) : (a << 1 ^ a ^ 0x11b); return a })
// }
// const EXP = calculate_exp()
// const LOG = Array.from({length: 256}, (_, i) => i == 0 ? 255 : EXP.indexOf(i))

// // The maximum is exclusive and the minimum is inclusive
// const random = (min, max) => Math.floor(Math.random() * (max - min) + min)

// const add = (a, b) => a ^ b
// const mul = (a, b) => a == 0 || b == 0 ? 0 : EXP[LOG[a] + LOG[b]]

// const eval     = (arr, x) => arr.reduceRight((result, b) => add(mul(result, x), b), 0)
// const generate = (rnd, degree, x) => [x].concat(Array.from({length: degree - 1}, () => rnd(0, 256))).concat([rnd(1, 256)])

// console.log("EXP")
// console.log(hexes(EXP))
// console.log("")

// console.log("LOG")
// console.log(hexes(LOG))
// console.log("")

// console.log("eval")
// console.log(hex(eval([20, 20],2)))
// console.log("")

// console.log("generate")
// console.log(hexes(generate(random, 10, 2)))
// console.log("")


// /*
// def split(random: RandomInt, secret: Array[Int], shares: Int, threshold: Int): Seq[Array[Int]] =
//   require((shares < 256) && (shares > 0) && (threshold <= shares) && (threshold > 0)) // FIXME threshold 1 ???
//   val polynomials = secret.map { b => generate(random, threshold - 1, b) }
//   (1 to shares).map { share => polynomials.map { polynomial => eval(polynomial, share) } }

// def generate(random: RandomInt, degree: Int, x: Int): Array[Int] =
//   x +: Array.fill(degree - 1)(random(0, 256)) :+ random(1, 256)

// def eval(a: Array[Int], x: Int) = a.foldRight(0) { case (b, result) => result #* x #+ b }
// */

</script>
  

</html>
